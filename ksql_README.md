# ksql queries

## Joining Applicant Data with Test Result Data

### ***Make sure that auto.offset.reset = Earliest***

Create a stream from Applicant data (Oracle)
```sql
CREATE STREAM APPLICANTS WITH (
  KAFKA_TOPIC='ORCLCDB.C__MYUSER.APPLICANTS', 
  VALUE_FORMAT='AVRO'
);
```

Sanity check for APPLICANTS Stream:
```sql
SELECT * FROM APPLICANTS EMIT CHANGES;
```

Create Stream from CSV Test Data
```sql
CREATE STREAM COUNTY_COVID_S
with (
KAFKA_TOPIC='county-covid',
VALUE_FORMAT='AVRO',
timestamp='Test_Date',
timestamp_format='MM/dd/yyyy'
);
```

Sanity check for COUNTY_COVID_S Stream:
```sql
SELECT * FROM  COUNTY_COVID_S EMIT CHANGES;
```

Run a SELECT query and change data type for some fields:
```sql
SELECT
PARSE_DATE(TEST_DATE, 'MM/dd/yyyy') AS ISOTESTDATE,
TEST_DATE,
COUNTY,
CAST(NEW_POSITIVES AS DOUBLE) AS NEW_POSITIVES,
CAST(CUMULATIVE_NUMBER_OF_POSITIVES AS DOUBLE) AS CUMULATIVE_NUMBER_OF_POSITIVES,
CAST(TOTAL_NUMBER_OF_TESTS_PERFORMED AS DOUBLE) AS TOTAL_NUMBER_OF_TESTS_PERFORMED,
CAST(CUMULATIVE_NUMBER_OF_TESTS_PERFORMED AS DOUBLE) AS CUMULATIVE_NUMBER_OF_TESTS_PERFORMED
FROM  COUNTY_COVID_S
EMIT CHANGES;
```

Create derived stream from this stream
```sql
CREATE STREAM DERIVED_COVID_S WITH (
  timestamp='TEST_DATE',
  timestamp_format='MM/dd/yyyy',
  KAFKA_TOPIC='derived_covid_s',
  VALUE_FORMAT='AVRO'
) AS
SELECT
PARSE_DATE(TEST_DATE, 'MM/dd/yyyy') AS ISOTESTDATE,
TEST_DATE,
COUNTY,
CAST(NEW_POSITIVES AS DOUBLE) AS NEW_POSITIVES,
CAST(CUMULATIVE_NUMBER_OF_POSITIVES AS DOUBLE) AS CUMULATIVE_NUMBER_OF_POSITIVES,
CAST(TOTAL_NUMBER_OF_TESTS_PERFORMED AS DOUBLE) AS TOTAL_NUMBER_OF_TESTS_PERFORMED,
CAST(CUMULATIVE_NUMBER_OF_TESTS_PERFORMED AS DOUBLE) AS CUMULATIVE_NUMBER_OF_TESTS_PERFORMED
FROM  COUNTY_COVID_S PARTITION BY COUNTY EMIT CHANGES;
```

Sanity check on derived Stream:
```sql
SELECT * FROM DERIVED_COVID_S EMIT CHANGES;
```
 
Run a JOIN query: 
 ```sql
SELECT
A.GIVENNAME + ' ' + A.MIDDLEINITIAL + ' ' + A.SURNAME AS FULLNAME,
A.STREETADDRESS, A.CITY, A.ZIPCODE,
S.COUNTY,
A.EMAILADDRESS,
A.BIRTHDAY,
S.ISOTESTDATE,
FROM_UNIXTIME(CAST(A.OP_TS AS BIGINT)) AS APPLICATION_TIME,
S.NEW_POSITIVES/S.TOTAL_NUMBER_OF_TESTS_PERFORMED * 100 AS POSITIVITY_RATE
FROM  DERIVED_COVID_S S JOIN APPLICANTS A WITHIN 3 DAYS ON S.COUNTY = A.COUNTY
WHERE NEW_POSITIVES/TOTAL_NUMBER_OF_TESTS_PERFORMED * 100 > 10.0
EMIT CHANGES;
```

If that query works - create a Stream from it!  This will create a new topic.

```sql
CREATE STREAM PRIORITY_APPLICANTS WITH (KAFKA_TOPIC='priority', VALUE_FORMAT='AVRO') AS
SELECT
A.GIVENNAME + ' ' + A.MIDDLEINITIAL + ' ' + A.SURNAME AS FULLNAME,
A.STREETADDRESS, A.CITY, A.ZIPCODE,
S.COUNTY,
A.EMAILADDRESS,
A.BIRTHDAY,
S.ISOTESTDATE,
FROM_UNIXTIME(CAST(A.OP_TS AS BIGINT)) AS APPLICATION_TIME,
S.NEW_POSITIVES/S.TOTAL_NUMBER_OF_TESTS_PERFORMED * 100 AS POSITIVITY_RATE
FROM  DERIVED_COVID_S S JOIN APPLICANTS A WITHIN 3 DAYS ON S.COUNTY = A.COUNTY
WHERE NEW_POSITIVES/TOTAL_NUMBER_OF_TESTS_PERFORMED * 100 > 10.0
PARTITION BY S.COUNTY
EMIT CHANGES;
```
## Finding fraud in application data
Use the ```COUNT``` function to count the number of times a Street address appears:
```sql
SELECT STREETADDRESS, COUNT(STREETADDRESS) AS N_STREET
FROM APPLICANTS
GROUP BY STREETADDRESS
EMIT CHANGES;
```
Turn that query into a Table:
```sql
CREATE TABLE ADDRESS_T WITH (KAFKA_TOPIC='ADDRESS_T', VALUE_FORMAT='AVRO') AS
SELECT STREETADDRESS, COUNT(STREETADDRESS) AS N_STREET
FROM APPLICANTS
GROUP BY STREETADDRESS
EMIT CHANGES;
```
Query that table to find addresses that occur more than once:
```sql
SELECT * FROM ADDRESS_T WHERE N_STREET > 1 EMIT CHANGES;
```
Find fraudsters:
```sql
SELECT ADDRESS_T.STREETADDRESS, ADDRESS_T.N_STREET,
APPLICANTS.SURNAME
FROM APPLICANTS
INNER JOIN ADDRESS_T on APPLICANTS.STREETADDRESS = ADDRESS_T.STREETADDRESS
WHERE ADDRESS_T.N_STREET > 1
EMIT CHANGES;
```
Create a new stream/topic from this query:
```sql
CREATE STREAM PHONIES WITH (KAFKA_TOPIC='PHONIES', VALUE_FORMAT='AVRO') AS
SELECT
APPLICANTS.GIVENNAME + ' ' + APPLICANTS.MIDDLEINITIAL + ' ' + APPLICANTS.SURNAME AS FULLNAME,
ADDRESS_T.STREETADDRESS AS ADDRESS,
APPLICANTS.CITY AS CITY,
APPLICANTS.ZIPCODE AS ZIP,
APPLICANTS.EMAILADDRESS, APPLICANTS.BIRTHDAY, APPLICANTS.NATIONALID, ADDRESS_T.N_STREET
FROM APPLICANTS
INNER JOIN ADDRESS_T on APPLICANTS.STREETADDRESS = ADDRESS_T.STREETADDRESS
WHERE ADDRESS_T.N_STREET > 1
EMIT CHANGES;
```
